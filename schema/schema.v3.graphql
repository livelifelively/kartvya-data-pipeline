# USER AUTHENTICATION
# values in camelcase are due to @auth/core adapter type definition

type Account {
  id: ID

  type: String
  provider: String @search(by: [hash])
  providerAccountId: String @search(by: [hash])
  refreshToken: String
  expires_at: Int64
  accessToken: String
  token_type: String
  refresh_token: String
  access_token: String
  scope: String
  id_token: String
  session_state: String
  user: User @hasInverse(field: "accounts")
}

type Session {
  id: ID

  expires: DateTime
  sessionToken: String @search(by: [hash])
  user: User @hasInverse(field: "sessions")
}

type User {
  id: ID

  name: String
  email: String @id
  emailVerified: DateTime
  image: String
  accounts: [Account] @hasInverse(field: "user")
  sessions: [Session] @hasInverse(field: "user")
  # citizen_profile: _Citizen_Profile_
}

type VerificationToken {
  id: ID

  identifier: String @search(by: [hash])
  token: String @search(by: [hash])
  expires: DateTime
}

# type _Citizen_Profile_ {
#   id: ID

#   user: User @hasInverse(field: "citizen_profile")

#   # followed administrative region entities
#   country: [_Administrative_Entity_]
#   state: [_Administrative_Entity_]
#   zonal_council: [_Administrative_Entity_]
#   district: [_Administrative_Entity_]
#   loksabha_constituency: [_Administrative_Entity_]
#   vidhansabha_constituency: [_Administrative_Entity_]

#   # policy subjects
#   # #TODO
# }

# language and scripts
# text, especially names can be in multiple languages and scripts
type _Language_ {
  id: ID!

  name_en: String! @id
  names: [String]
  scripts: [_Script_]

  wikidata_qid: String @search(by: [hash])
  wikipedia_page: String @search(by: [fulltext])
  # last update date of the wikipedia data.
  # if this date changed on wikipedia, we should consider updating
  wikipedia_page_data_version: DateTime
}

type _Script_ {
  id: ID!

  name_en: String! @id
  names: [String]
  languages: [_Language_] @hasInverse(field: "scripts")

  wikidata_qid: String @search(by: [hash])
  wikipedia_page: String @search(by: [fulltext])
  # last update date of the wikipedia data.
  # if this date changed on wikipedia, we should consider updating
  wikipedia_page_data_version: DateTime
}

# instance of language + script combination.
type _Language_Script_ {
  id: ID!

  name_en: String! @id
  language: _Language_!
  script: _Script_!
}

# the "WHO" of 5W1H #ENTRY_NODE
# #ENTRY_NODE
# name of all entities in the knowledge graph.
# an entry point for all.
# one name can be shared by multiple entities.
type _Name_ {
  id: ID!

  language_script: [_Language_Script_!]!
  name: String! @id @search(by: [hash, term, fulltext])

  indian_legal_document: [_Indian_Legal_Document_]
  country: [_Country_]
  in_zonal_council: [_IN_Zonal_Council_]

  country_event: [_Country_Event_]
}

enum _Location_Or_Region_Category_ {
  Location
  Region
}

enum _Geo_Precision_ {
  # e.g. countries in world map on low res map image
  Extra_Low
  Low
  Medium
  High
  Very_High
  Near_Real_World
}

# the "WHERE" of 5W1H
# #ENTRY_NODE
# tile by tile geo information and how its related to political regions
type _Geo_ {
  id: ID!
  # CHANGE: not to include category, if has location,
  category: _Location_Or_Region_Category_ @search(by: [exact])

  # if the category is location
  location: Point @search

  # if the category is region
  area: MultiPolygon @search

  precision: Int @search

  country_boundary_actual: _Country_Region_
  country_boundary_official: _Country_Region_
  country_boundary_world_official: _Country_Region_

  in_zonal_council_boundary: _Country_Region_
  in_state_boundary: _Country_Region_
  in_union_territory_boundary: _Country_Region_
  in_district_boundary: _Country_Region_
  in_vidhansabha_constituency_boundary: _Country_Region_
  in_loksabha_constituency_boundary: _Country_Region_
}

enum Date_Time_Precision_Category {
  Year
  Month
  Day
  Hour
  Minute
  Second
}

type _Date_Time_ {
  id: ID!

  date_time: DateTime @search(by: [hour])
  date_time_precision: Date_Time_Precision_Category @search(by: [exact])

  country_event_from: [_Country_Event_]
  # end date for ranged events
  country_event_to: [_Country_Event_]
}

type _Country_ {
  id: ID!
  name_id: String! @id

  names: [_Name_!]! @hasInverse(field: "country")

  region: [_Country_Region_]

  legal: [_Country_Legal_]

  events: [_Country_Event_]
}

# political regions associated with and within a country
type _Country_Region_ {
  id: ID!

  country: _Country_ @hasInverse(field: "region")

  # date on which the region changed
  # e.g. sikkim added to India
  # version: DateTime @search

  established_on: _Country_Event_
  disestablished_on: _Country_Event_

  # how the country region related to other region types
  capital: [_Countryal_Capital_City_]
  zonal_council: [_IN_Zonal_Council_Region_] @hasInverse(field: "country")
  state: [_IN_State_Region_] @hasInverse(field: "country")
  union_territory: [_IN_Union_Territory_Region_] @hasInverse(field: "country")

  # array because, there can be multiple version with varying precision.
  # low precision for maps, high precicion for search and computation
  geo_boundary_self_actual: [_Geo_]

  # boundaries recognized by the national authorities
  # e.g. PoK is part of India as per Indian government, although its not under GOI administration
  geo_boundary_self_official: [_Geo_]
  geo_boundary_world_official: [_Geo_]

  geo_political_country_zonal_council: [_Geo_]
  geo_political_country_state_union_territory: [_Geo_]
  geo_political_country_district: [_Geo_]
  geo_political_country_loksabha_constituency: [_Geo_]
  geo_political_country_vidhansabha_constituency: [_Geo_]
}

type _Country_Government_ {
  id: ID!
  name_id: String! @id

  names: [Name!]! @hasInverse(field: "country_government")
  governs_country: _Country_
}

# the "WHAT" of 5W1H.
# will have to have multiple node types for the events.
#
type _Country_Event_ {
  id: ID!

  # if involves multiple countrys
  country: [_Country_]

  # specific to this event. should be able to identify the event and country.
  # would be best if the value can be unique, though not setting that as a condition as of now.
  names: [_Name_] @hasInverse(field: "country_event")
  description: String! @search(by: [exact, fulltext, term])

  # broad categories. "term criteria": can be applicable to any country.
  # "Declared Independence", "Civil War", "Independence Day", "Declared as Republic", "Declared War", "Hoasted Olympic", "Launched a Sattelite"
  # cannot be an enum (at least at this point) since can have too many values,
  # unless we reach a point where we have a sure number which may not change much.
  event_type: String! @search(by: [exact, fulltext, term])

  # time range event or one time
  one_time_event: Boolean

  date_from: _Date_Time_! @hasInverse(field: "country_event_to")
  date_to: _Date_Time_ @hasInverse(field: "country_event_from")

  # #TODO
  # repeated_event_details:
}

enum _Indian_Legal_Document_Category_ {
  Constitution
  Bill
  Act
  Notification
  Rules
  Regulation
  Order
}

type _Indian_Legal_Document_ {
  id: ID!

  # english title that can be searched
  name_id: String! @id @search(by: [hash, term, fulltext])

  # title in multiple languages
  names: [_Name_!]! @hasInverse(field: "indian_legal_document")

  description: String
  document_type: _Indian_Legal_Document_Category_! @search(by: [exact])

  is_notified: Boolean!

  active_version: _Indian_Legal_Document_Version_
  versions: [_Indian_Legal_Document_Version_]

  structural_elements: [_Indian_Legal_Document_Structural_Element_]
  amendments: [_Indian_Legal_Document_Amendment_]

  enactment_date: DateTime @search
  enforcement_date: DateTime @search
}

enum _Indian_Legal_Document_Structural_Element_Category_ {
  Article
  Section
  Preamble
}

type _Indian_Legal_Document_Structural_Element_ {
  id: ID!

  # which legal document it is part of
  legal_document: _Indian_Legal_Document_! @hasInverse(field: "structural_elements")
  # type of element
  element_type: _Indian_Legal_Document_Structural_Element_Category_! @search(by: [exact])

  # if section/article has a number or roman number or alpha-numeric value in the original document
  identifier: String @search

  part: String @search(by: [exact])
  chapter: String @search(by: [exact])
  schedule: String @search(by: [exact])

  # title of the document
  title: String @search(by: [term, fulltext])
  is_active: Boolean @search
  text_unformatted: [String!] @search(by: [term, fulltext])
  text_formatted: [String!] @search(by: [term, fulltext])

  # if the structural element is from an amendment
  amendment: _Indian_Legal_Document_Amendment_

  # all versions this structural element is part of
  part_of_versions: [_Indian_Legal_Document_Version_]
  # ommited_in_versions: [_Indian_Legal_Document_Version_]

  # date on which this element was added to the knowledge graph
  created_on: DateTime
}

type _Indian_Legal_Document_Version_ {
  id: ID!

  version: DateTime @search

  is_active_version_of: _Indian_Legal_Document_ @hasInverse(field: "active_version")
  legal_document: _Indian_Legal_Document_! @hasInverse(field: "versions")

  structural_elements: [_Indian_Legal_Document_Structural_Element_!]! @hasInverse(field: "part_of_versions")

  # if amendment is null, means original document
  previous_version: _Indian_Legal_Document_Version_ @hasInverse(field: "next_version")
  next_version: _Indian_Legal_Document_Version_ @hasInverse(field: "previous_version")

  amendment: _Indian_Legal_Document_Amendment_
}

type _Indian_Legal_Document_Amendment_ {
  id: ID!

  legal_document: _Indian_Legal_Document_! @hasInverse(field: "amendments")

  resulting_version: _Indian_Legal_Document_Version_ @hasInverse(field: "amendment")

  # structural elements introduced by this ammendment
  structural_elements: [_Indian_Legal_Document_Structural_Element_] @hasInverse(field: "amendment")

  amendment_date: DateTime!
  description: String

  change_description: String
}
